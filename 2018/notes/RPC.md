# Remote Procedure Call

RPC是一种客户端和服务器交互的方式，RPC理想上想把网络通信做的跟本地的函数调用一样。

RPC的目标：

- 简化编写网络通信程序
- 隐藏客户端服务器通信复杂的细节
- 为程序员提供相似的模型（就像本地的函数调用）
- 实现分布式计算的工具

RPC的透明度：

Client:
```
z = fn(x, y)
```

Server:
```
 fn(x, y) {
		compute
	return z
  }
```

RPC要实现这种水平的透明度，对远程进程的调用就像是对本地的调用。

RPC架构：

![](http://ohr9krjig.bkt.clouddn.com/Screen%20Shot%202018-10-18%20at%2016.58.59.png)

可以看到 客户端和 服务器端 都是和各自的stub交互，stub和RPC底层代码交互，RPC底层代码最终依靠 网络传输协议 联通客户端和 服务器 最终实现 RPC。

client stub和server stub是为了实现透明的RPC设计的。

client stub：
1. 序列化参数
2. 发送请求到server
3. 等待响应
4. 反序列化返回的结果，返回给RPC的调用者

server stub：
1. 反序列化参数，构建堆栈（函数调用的参数在栈中）
2. 调用client请求的进程
3. 序列化结果，并返回

可以看出 stub的工作主要序列化和反序列化，为程序员编程提供一个统一的接口。
所以，RPC的流程如下：

1. 客户端调用 client stub
2. client stub 构建、序列化信息（参数等），调用操作系统方法
3. 客户端操作系统发送信息到远程（服务器）的操作系统
4. 远程操作系统将获得的信息传递给server stub
5. server stub反序列化信息，调用相应的server进程
6. server进程进行计算，返回结果到 server stub
7. server stub序列化结果，调用操作
8. server的操作系统发送信息到client的操作系统
9. client操作传递给client stub
10. client stub 反序列化响应，返回给RPC的调用者

同步RPC：

同步RPC就是传统RPC调用，在server收到client请求，进行计算的时候，client一直在等待，直到server返回结果。

异步RPC：

异步RPC需要client和server之间两次交互。

第一次client发送请求之后，一直等待，直到收到server返回的接受请求的信息（只是表示server接受了这个请求，还没计算完），client不再等待，q处理别的事务了。 等到server的进程调用结束之后，server再向client发送函数调用的结果（这个时候结算结束，返回计算结果），client被server的返回中断，获得RPC的结果，client在给server发送一个信息表示它已经接收到结果。

RPC的失败处理：

RPC调用的失败比LPC（本地进程调用）复杂，因为LPC失败就是因为进程调用的过程出错，但是RPC的失败有多种原因（丢包，网络断线，服务器运行缓慢，服务器崩溃等），针对RPC失败的处理也会有所不同。

失败原因：

1. client请求的时候网络出错
2. server上进程调用的时候出错，可能执行前出错，也可能执行后出错
3. 从server返回结果的时候网络出错
4. client接收结果的时候出错 

针对这些错误，要有相应的错误处理机制。

对于每一个RPC，我们希望它只执行一次（一次并且成功），但是这是无法保证的。

有如下两种方案：

1. 至少一次。 client一直发送请求直到得到一个相应，server对接收到的每一个请求都执行，要求这个请求是幂等的。

2. 至多一次。 server对于同一个请求只执行一次，虽然可能会多次接收到同一个请求。所以需要用独一无二的ID标记每个请求，server会缓存已经执行过的请求的结果，对于一个请求，如果已经发现执行过，就从缓存中取出，直接返回；使用一个滑动窗口保存有效的请求的ID（不能全部保存，内存占太多）。至多一次策略的结果是请求被成功执行一次或零次，RPC库等待回复一段时间，如果还是没有回复到达，重新发生请求。重复多次，如果还是没有回复，那么返回错误给应用程序（这就是零次）。 对于不幂等的请求，要使用至多一次。

内存获取：

RPC调用的时候最好不要使用指针，指针是本地地址，RPC调用的是远程进程，使用指针会把事情变复杂。


